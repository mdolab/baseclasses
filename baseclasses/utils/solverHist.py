"""
==============================================================================
BaseClasses: Solver History Class
==============================================================================
@File    :   SolverHist.py
@Date    :   2020/11/30
@Author  :   Alasdair Christison Gray
@Description :
"""

# ==============================================================================
# Standard Python modules
# ==============================================================================
from warnings import warn
import copy
import os

# ==============================================================================
# External Python modules
# ==============================================================================
import numpy as np

# ==============================================================================
# Extension modules
# ==============================================================================


class SolverHist(object):
    """
    The SolverHist class stores various useful values during a nonlinear solution in a nested dictionary structure, by
    default, the history only stores the values from the latest iteration which are used for printing to the terminal.
    Storing of the full solution history is enabled using the 'writeConvergenceHist' option
    """

    def __init__(self, options):
        """
        Create an empty history dictionary based on the current solver options
        """

        length = options["maxincrements"] * (options["nnliter"] + 1)
        self.storeValues = True

        # Make a local copy of the options
        self.options = options

        # Define some defaults
        self.defaults = {"values": {}, "valueFormat": {}}
        self.defaults["valueFormat"]["float"] = "{:17.11e}"
        self.defaults["values"]["float"] = np.full(length, np.nan)

        self.defaults["valueFormat"]["int"] = "{:03d}"
        self.defaults["values"]["int"] = [np.nan] * length

        self.defaults["valueFormat"]["other"] = "{:^40}"
        self.defaults["values"]["other"] = [None] * length

        self.hist = {"values": {}, "valueFormat": {}, "nameFormat": {}, "varType": {}}
        self.varsToPrint = []
        self.latestIter = 0

        self.addField(Name="Iter", Type=int, ValueFormat=None, NameFormat=None, Print=True)

    def addField(self, Name, Type, ValueFormat=None, NameFormat=None, Print=False):
        """Add a field to the solution history"""

        if Print:
            self.varsToPrint.append(Name)

        if Type in [float, np.float64, np.float32]:
            varType = "float"
            testValue = 0.0
        elif Type is int:
            varType = "int"
            testValue = 0
        else:
            varType = "other"
            testValue = " "

        self.hist["varType"][Name] = varType

        if ValueFormat is None:
            ValueFormat = copy.deepcopy(self.defaults["valueFormat"][varType])

        if NameFormat is None:
            testString = ValueFormat.format(testValue)
            # If name is longer than the value then name format should be length of name and value format should be
            # lengthened, otherwise make name format the same length as value format
            if len(Name) > len(testString):
                NameFormat = "{:^%i}" % len(Name)
                spacesToAdd = len(Name) - len(testString)
                ValueFormat = " " * (spacesToAdd - spacesToAdd // 2) + ValueFormat + " " * (spacesToAdd // 2)
            else:
                NameFormat = "{:^%i}" % len(testString)

        # Now actually add the entry
        self.hist["values"][Name] = copy.deepcopy(self.defaults["values"][varType])
        self.hist["valueFormat"][Name] = ValueFormat
        self.hist["nameFormat"][Name] = NameFormat

    def addUserFuncVars(self, Solver, UserFunc):
        """Add the variables generated by a user supplied function to those tracked by the SolverHist object"""

        data = UserFunc(Solver)
        varsToPrint = [string.lower() for string in self.options["monitorvars"]]
        for key, val in data.items():
            if key not in self.hist["nameFormat"]:
                print("Adding output: '%s', from user supplied function to Solver History" % key)

                Print = key.lower() in varsToPrint
                self.addField(Name=key, Type=type(val), Print=Print)
            else:
                warn(
                    "Can't add variable: '%s', from user supplied function to Solver History as there is already a tracked variable with this name, skipping"
                    % key
                )

    def reset(self):
        """
        Reset the solver history log
        """
        self.latestIter = 0

        for key in self.hist["values"]:
            varType = self.hist["varType"][key]
            self.hist["values"][key] = copy.deepcopy(self.defaults["values"][varType])

    def write(self, data):
        """
        Store the values from the latest iteration in the solver history
        """

        # Figure out if we're storing the history or not
        if self.storeValues:
            i = self.latestIter
        else:
            i = 0

        self.hist["values"]["Iter"][i] = self.latestIter
        for key, val in data.items():
            try:
                self.hist["values"][key][i] = val
            except KeyError:
                raise KeyError("Option '%-30s' is not a valid history variable." % (key))

        self.latestIter += 1

    def printHeader(self):
        """
        Print the formatted header, used during nonlinear solution process
        """
        header = "|"
        for var in self.varsToPrint:
            if var in self.hist["nameFormat"]:
                header += " " + self.hist["nameFormat"][var].format(var) + " |"

        print("+" + "-" * (len(header) - 2) + "+")
        print(header)
        print("+" + "-" * (len(header) - 2) + "+")

    def printData(self, ind=None):
        """
        Print a selection of the history in the correctly formatted manner, used for printing convergence history during
        nonlinear solution process
        """
        if ind == None:
            ind = [self.latestIter - 1]
        if type(ind) is not list:
            ind = [ind]
        if not self.storeValues and (len(ind) > 1 or all(i not in [0, -1] for i in ind)):
            warn(
                'Previous iterations unavailable as py option "writeConvergenceHist" is not enabled. Printing latest iteration'
            )
            ind = [self.latestIter - 1]

        for iter in ind:
            if iter < self.latestIter:
                line = "|"
                for var in self.varsToPrint:
                    if var in self.hist["nameFormat"]:
                        if self.hist["varType"][var] in ["float", "int"] and np.isnan(self.hist["values"][var][iter]):
                            line += " " + self.hist["nameFormat"][var].format("-") + " |"
                        else:
                            line += " " + self.hist["valueFormat"][var].format(self.hist["values"][var][iter]) + " |"
                print(line)

    def clip(self):
        """
        Remove the unused entries in the history dict
        """

        for key in self.hist["values"]:
            self.hist["values"][key] = self.hist["values"][key][: self.latestIter]

    def save(self, filename):
        """Postprocess the history and save as a pickled dictionary"""

        import dill as pickle

        base = os.path.splitext(filename)[0]
        filename = base + ".pkl"

        # Remove the unused entries
        self.clip()

        # Store the options this problem ran with
        self.hist["options"] = self.options

        pickle.dump(self.hist, open(filename, "wb"), protocol=pickle.HIGHEST_PROTOCOL)
